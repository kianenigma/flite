<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="This crate implements a simple binary Merkle Tree utilities required for inter-op with Ethereum bridge &#38; Solidity contract."><title>binary_merkle_tree - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-46f98efaafac5295.ttf.woff2,FiraSans-Regular-018c141bf0843ffd.woff2,FiraSans-Medium-8f9a781e4970d388.woff2,SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2,SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../static.files/rustdoc-b25d77b18a16a9a4.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="binary_merkle_tree" data-themes="" data-resource-suffix="" data-rustdoc-version="1.82.0-nightly (13a52890d 2024-08-14)" data-channel="nightly" data-search-js="search-ef54e092fea9c776.js" data-settings-js="settings-4313503d2e1961c2.js" ><script src="../static.files/storage-118b08c4c78b968e.js"></script><script defer src="../crates.js"></script><script defer src="../static.files/main-cb0df477c2d67d00.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-3b12f09e550e0385.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../binary_merkle_tree/index.html">binary_<wbr>merkle_<wbr>tree</a><span class="version">13.0.0</span></h2></div><div class="sidebar-elems"><ul class="block"><li><a id="all-types" href="all.html">All Items</a></li></ul><section><ul class="block"><li><a href="#structs">Structs</a></li><li><a href="#enums">Enums</a></li><li><a href="#functions">Functions</a></li></ul></section></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><h1>Crate <a class="mod" href="#">binary_merkle_tree</a><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><span class="out-of-band"><a class="src" href="../src/binary_merkle_tree/lib.rs.html#18-809">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>This crate implements a simple binary Merkle Tree utilities required for inter-op with Ethereum
bridge &amp; Solidity contract.</p>
<p>The implementation is optimised for usage within Substrate Runtime and supports no-std
compilation targets.</p>
<p>Merkle Tree is constructed from arbitrary-length leaves, that are initially hashed using the
same hasher as the inner nodes.
Inner nodes are created by concatenating child hashes and hashing again. The implementation
does not perform any sorting of the input data (leaves) nor when inner nodes are created.</p>
<p>If the number of leaves is not even, last leaf (hash of) is promoted to the upper layer.</p>
</div></details><h2 id="structs" class="section-header">Structs<a href="#structs" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="struct" href="struct.MerkleProof.html" title="struct binary_merkle_tree::MerkleProof">Merkle<wbr>Proof</a></div><div class="desc docblock-short">A generated merkle proof.</div></li></ul><h2 id="enums" class="section-header">Enums<a href="#enums" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="enum" href="enum.Leaf.html" title="enum binary_merkle_tree::Leaf">Leaf</a></div><div class="desc docblock-short">Leaf node for proof verification.</div></li></ul><h2 id="functions" class="section-header">Functions<a href="#functions" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="fn" href="fn.merkle_proof.html" title="fn binary_merkle_tree::merkle_proof">merkle_<wbr>proof</a></div><div class="desc docblock-short">Construct a Merkle Proof for leaves given by indices.</div></li><li><div class="item-name"><a class="fn" href="fn.merkle_root.html" title="fn binary_merkle_tree::merkle_root">merkle_<wbr>root</a></div><div class="desc docblock-short">Construct a root hash of a Binary Merkle Tree created from given leaves.</div></li><li><div class="item-name"><a class="fn" href="fn.verify_proof.html" title="fn binary_merkle_tree::verify_proof">verify_<wbr>proof</a></div><div class="desc docblock-short">Verify Merkle Proof correctness versus given root hash.</div></li></ul></section></div></main></body></html>
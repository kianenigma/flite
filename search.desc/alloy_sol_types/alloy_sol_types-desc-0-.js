searchState.loadedDescShard("alloy_sol_types", 0, "Solidity type modeling and ABI and EIP-712 codec …\nWhether the event is anonymous.\nThe underlying tuple type which represents this type’s …\nArray out of bounds access.\nUsed by the <code>assert()</code> builtin.\nThe number of variants in the enum.\nThe number of topics.\nThe number of variants.\nA generic contract error.\nA contract’s custom error.\nA contract’s custom error.\nWhether the encoded size is dynamic.\nWhether the encoded size is dynamic.\nThe <code>TokenSeq</code> type corresponding to the tuple.\nThe underlying tuple type which represents this event’s …\nDivision or modulo by zero.\nThe encoded size of the type, if known at compile time\nThe encoded size of the type, if known at compile time\nEip712 Domain attributes used in determining the domain …\nEmpty array pop.\nEnum conversion error.\nContains the error value\nABI Encoding and Decoding errors.\nA Solidity event topic.\nHex error.\nGeneric / unspecified error.\nA generic contract error.\nInvalid enum value.\nCalling invalid internal function.\nThe minimum length of the data for this type.\nThe name of this type.\nThe struct name.\nThe name of the struct.\nContains the success value\nOther errors.\nOverran deserialization buffer.\nA Solidity panic.\nA panic. See <code>Panic</code> for more information.\nA panic. See <code>Panic</code> for more information.\nRepresents a Solidity panic. Same as the Solidity …\nThe underlying tuple type which represents the error’s …\nValidation reserialization did not match input.\nResource error (too large allocation or too large array).\nABI result type.\nThe function’s return struct.\nThe returns’ corresponding TokenSeq type.\nThe underlying tuple type which represents this type’s …\nRepresents a standard Solidity revert. These are thrown by …\nA generic revert. See <code>Revert</code> for more information.\nA generic revert. See <code>Revert</code> for more information.\nThe corresponding Rust type.\nThe error selector: <code>keccak256(SIGNATURE)[0..4]</code>\nThe function selector: <code>keccak256(SIGNATURE)[0..4]</code>\nThe error’s ABI signature.\nThe event’s ABI signature.\nThe function’s ABI signature.\nThe event’s ABI signature hash, or selector: …\nIterator over the function or error selectors of a …\nSolidity call (a tuple with a selector).\nSolidity enum. This is always a wrapper around a <code>u8</code>.\nSolidity Error (a tuple with a selector)\nSolidity event.\nA collection of ABI-encoded call-like types. This …\nA Solidity Struct.\nA Solidity type.\nThe Solidity type that this type corresponds to.\nSolidity values.\nInvalid encoding in storage.\nThe corresponding <code>TokenSeq</code> type.\nThe arguments’ corresponding TokenSeq type.\nThe corresponding ABI token type.\nA <code>TopicList</code> represents the topics of a Solidity event.\nThe underlying tuple type which represents this event’s …\nA typecheck detected a word that does not match the data …\nArithmetic underflow or overflow.\nUnknown selector.\nThe ABI word type.\nEthereum ABI codec implementation.\nABI decode the enum from the given buffer.\nABI decode the enum from the given buffer.\nABI decode this error’s arguments from the given slice, …\nABI decode this error’s arguments from the given slice, …\nABI decode this call’s arguments from the given slice, …\nABI decode this call’s arguments from the given slice, …\nABI-decodes the given data into one of the variants of <code>self</code>…\nABI-decodes the given data into one of the variants of <code>self</code>…\nABI-decode this type from the given data.\nABI-decode this type from the given data.\nDecodes this type’s value from an ABI blob by …\nDecodes this type’s value from an ABI blob by …\nABI-decodes the dynamic data of this event from the given …\nABI-decodes the dynamic data of this event from the given …\nABI-decode this type from the given data.\nABI-decode this type from the given data.\nDecodes this type’s value from an ABI blob by …\nDecodes this type’s value from an ABI blob by …\nABI-decodes the given data into one of the variants of <code>self</code>…\nABI decode this call’s arguments from the given slice, …\nABI decode this call’s arguments from the given slice, …\nABI decode this call’s arguments from the given slice, …\nABI decode this call’s arguments from the given slice, …\nABI decode this call’s return values from the given …\nABI-decode this type from the given data.\nABI-decode this type from the given data.\nDecodes this type’s value from an ABI blob by …\nDecodes this type’s value from an ABI blob by …\nABI encode the enum.\nABI encode the enum.\nABI encode the error to the given buffer <strong>with</strong> its selector.\nABI encode the error to the given buffer <strong>with</strong> its selector.\nABI encode the call to the given buffer <strong>with</strong> its selector.\nABI encode the call to the given buffer <strong>with</strong> its selector.\nABI-encodes <code>self</code> into the given buffer.\nABI-encodes <code>self</code> into the given buffer.\nABI-encodes the value.\nABI-encodes the value.\nTokenizes and ABI-encodes the given value by wrapping it …\nTokenizes and ABI-encodes the given value by wrapping it …\nNon-standard Packed Mode ABI encoding.\nNon-standard Packed Mode ABI encoding.\nNon-standard Packed Mode ABI encoding.\nNon-standard Packed Mode ABI encoding.\nNon-standard Packed Mode ABI encoding.\nNon-standard Packed Mode ABI encoding.\nNon-standard Packed Mode ABI encoding.\nNon-standard Packed Mode ABI encoding.\nEncodes an ABI sequence suitable for function parameters.\nEncodes an ABI sequence suitable for function parameters.\nTokenizes and ABI-encodes the given value as function …\nTokenizes and ABI-encodes the given value as function …\nABI-encodes <code>self</code> into the given buffer, <em>without</em> any …\nABI encode the enum into the given buffer.\nABI encode the enum into the given buffer.\nABI encode the error to the given buffer <strong>without</strong> its …\nABI encode the error to the given buffer <strong>without</strong> its …\nABI encode the call to the given buffer <strong>without</strong> its …\nABI encode the call to the given buffer <strong>without</strong> its …\nABI encode the call’s return values.\nABI encode the call’s return values.\nEncodes an ABI sequence.\nEncodes an ABI sequence.\nTokenizes and ABI-encodes the given value as a sequence.\nTokenizes and ABI-encodes the given value as a sequence.\nThe size of the encoded data, <em>without</em> any selectors.\nThe size of the error params when encoded in bytes, <strong>without</strong>…\nThe size of the error params when encoded in bytes, <strong>without</strong>…\nThe size of the ABI-encoded dynamic data in bytes.\nThe size of the ABI-encoded dynamic data in bytes.\nThe size of the encoded data in bytes, <strong>without</strong> its …\nThe size of the encoded data in bytes, <strong>without</strong> its …\nCalculate the ABI-encoded size of the data.\nCalculate the ABI-encoded size of the data.\nCalculate the ABI-encoded size of the data, counting both …\nCalculate the ABI-encoded size of the data, counting both …\nReturns the number of bytes that will be used to encode …\nReturns an immutable reference to the inner custom error …\nReturns a mutable reference to the inner custom error if …\nReturns an immutable reference to the inner <code>Panic</code> if <code>self</code> …\nReturns a mutable reference to the inner <code>Panic</code> if <code>self</code> …\nReturns an immutable reference to the inner <code>Revert</code> if <code>self</code> …\nReturns a mutable reference to the inner <code>Revert</code> if <code>self</code> …\nReturns the panic code’s string representation.\nThe EIP-155 chain id. The user-agent should refuse signing …\nThe Solidity panic code.\nInstantiates a new error with a static str.\nDecode the event from the given log info.\nDecode the event from the given log info.\nDecode the event from the given log object.\nDecode the event from the given log object.\nReturns the revert reason from the given output data. …\nDecode the topics of this event from the given data.\nDecode the topics of this event from the given data.\nDefine a Solidity user-defined value type.\nDetokenize the topics into a tuple of rust types.\nDetokenize this type’s value from the given token.\nTokenizes the given value into this type’s token.\nTokenizes the given value into this type’s token.\nReturns component EIP-712 types. These types are used to …\nEncode this data according to EIP-712 <code>encodeData</code> rules, …\nEncode this data according to EIP-712 <code>encodeData</code> rules, …\nEncode this data according to EIP-712 <code>encodeData</code> rules, …\nEncode this data according to EIP-712 <code>encodeData</code> rules, …\nConvenience macro to instantiate an EIP-712 domain.\nEIP-712 <code>encodeData</code> …\nEIP-712 <code>encodeType</code> …\nEIP-712 <code>encodeType</code> …\nEIP-712 <code>hashStruct</code> …\nEIP-712 <code>hashStruct</code> …\nReturn the root EIP-712 type. This type is used to …\nEIP-712 <code>signTypedData</code> …\nEIP-712 <code>signTypedData</code> …\nEIP-712 <code>typeHash</code> …\nEIP-712 <code>typeHash</code> …\nABI-encode the dynamic data of this event.\nABI-encode the dynamic data of this event.\nEIP-712 <code>encodeData</code>: …\nABI-encode the dynamic data of this event into the given …\nABI-encode the dynamic data of this event into the given …\nEIP-712 <code>encodeData</code> into the given buffer: …\nIndexed event parameter encoding.\nEncodes this type as preimage bytes which are then hashed …\nEncode the topics of this event.\nEncode the topics of this event.\nEncode the topics of this event into a fixed-size array.\nEncode the topics of this event into a fixed-size array.\nEncode the topics of this event into the given buffer.\nEIP-712 <code>encodeType</code>: …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the panic code for the given number if it is a …\nEIP-712 <code>hashStruct</code>: …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns <code>true</code> if <code>self</code> matches <code>CustomError</code>.\nReturns <code>true</code> if <code>self</code> matches <code>Panic</code>.\nReturns <code>true</code> if <code>self</code> matches <code>Revert</code>.\nReturns the PanicKind if this panic code is a known …\nThe user readable name of signing domain, i.e. the name of …\nConvert from the tuple type used for ABI encoding and …\nConvert decoded rust data to the event type.\nConvert from the tuple type used for ABI encoding and …\nInstantiate a new domain.\nReturns the number of words that will be used to encode …\nReturns the revert reason string, or <code>&quot;&lt;empty&gt;&quot;</code> if empty.\nThe reason string, provided by the Solidity contract.\nA disambiguating salt for the protocol. This can be used …\nThe selector of this instance.\nThe selector of this type at the given index, used in …\nReturns an iterator over the selectors of this type.\nReturns an iterator over the selectors of this type.\nCalculate the domain separator for the domain object.\nSolidity types.\nThe name of this type in Solidity.\nThe name of the associated Solidity type.\nThe name of the associated Solidity type.\nConvert to the token type used for EIP-712 encoding and …\nTokenize the call’s arguments.\nTokenize the enum.\nTokenize the enum.\nDetokenize a value from the given token.\nDetokenize a value from the given token.\nTokenizes the given value into this type’s token.\nTokenizes the given value into this type’s token.\nTokenize the event’s non-indexed parameters.\nThe number of bytes this type occupies in another topic’…\nThe event’s topics.\nReturns an error if the given selector is not known to …\nReturns an error if the given selector is not known to …\nReturns an error if the given token cannot be detokenized …\nReturns an error if the given token cannot be detokenized …\nInstantiates a new <code>Error::TypeCheckFail</code> with the provided …\nInstantiates a new <code>Error::TypeCheckFail</code> with the provided …\nInstantiates a new <code>Error::TypeCheckFail</code> with the provided …\nEIP-712 <code>typeHash</code>: …\nInstantiates a new <code>Error::UnknownSelector</code> with the …\nUtilities used by different modules.\nReturns <code>true</code> if the given selector is known to this type.\nReturns <code>true</code> if the given token can be detokenized with …\nThe address of the contract that will verify the signature.\nThe current major version of the signing domain. …\nHex-encoded data.\nThe Solidity type we failed to produce.\nThe maximum valid value.\nThe name of the enum.\nThe type name.\nThe unknown selector.\nThe invalid value.\nThe <code>Decoder</code> wraps a byte slice with necessary info to …\nAn ABI encoder.\nShortcut for appending a token sequence.\nAppend a pointer to the current suffix offset.\nAppend a sequence of bytes as a packed sequence with a …\nAppend a sequence length.\nAppend a word to the encoder.\nBump the suffix offset by a given number of words.\nABI-decodes a token by wrapping it in a single-element …\nDecodes a single token from the underlying buffer.\nABI-decodes top-level function args.\nDecodes ABI compliant vector of bytes into vector of …\nDecodes a sequence of tokens from the underlying buffer.\nABI-encodes a single token.\nABI-encodes a tuple as ABI function params, suitable for …\nABI-encodes a token sequence.\nFinish the encoding process, returning the encoded words.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nFinish the encoding process, returning the encoded bytes.\nInstantiate a new empty encoder.\nInstantiate a new decoder from a byte slice and a …\nReturns the current offset in the buffer.\nPeek into the buffer.\nPeek a slice of size <code>len</code> from the buffer without advancing …\nPeek a slice of size <code>len</code> from the buffer at a specific …\nPeek the next word as a u32.\nPeek a u32 from the buffer at a specific offset, without …\nPeek the next word from the buffer without advancing the …\nPeek a word from the buffer at a specific offset, without …\nRemoves the last offset and returns it.\nAppends a suffix offset.\nGet a child decoder at the current offset.\nSets the current offset in the buffer.\nDetermine the current suffix offset.\nReturn a child decoder by consuming a word, interpreting …\nTakes the offset from the child decoder and sets it as the …\nTakes a slice of bytes of the given length by consuming up …\nTake a u32 from the buffer by consuming a word.\nTake a word from the buffer, advancing the offset.\nEthereum ABI tokens.\nTrue if this decoder is validating type correctness.\nInstantiate a new encoder with a given capacity in words.\nTrue if the token represents a dynamically-sized type.\nA Dynamic Sequence - <code>T[]</code>\nA Fixed Sequence - <code>T[N]</code>\nTrue for tuples only.\nA Packed Sequence - <code>bytes</code> or <code>string</code>\nA token composed of a sequence of other tokens.\nEthereum ABI tokens.\nA single EVM word - T for any value type.\nReturns a reference to the array.\nReturns a reference to the word as a slice.\nReturns a reference to the array as a slice.\nReturns a reference to the backing slice.\nReturns a reference to the slice.\nDecode a token from a decoder.\nABI-decode the token sequence from the encoder.\nABI-encode the token sequence into the encoder.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nAppend head words to the encoder.\nCalculate the number of head words.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nTake the backing array, consuming the token.\nConsumes <code>self</code> to return the underlying vector.\nCreate a new word token from a word.\nAppend tail words to the encoder.\nCalculate the number of tail words.\nCalculate the total number of head and tail words.\nAddress - <code>address</code>\nArray - <code>T[]</code>\nThe number of bits in the integer: <code>BITS</code>\nThe number of bytes in the integer: <code>BITS / 8</code>\nThe number of bytes in the integer: <code>BITS / 8</code>\nBool - <code>bool</code>\nSpecifies the number of bytes in a <code>FixedBytes</code> array as a …\nBytes - <code>bytes</code>\nFixedArray - <code>T[M]</code>\nFixedBytes - <code>bytesX</code>\nFunction - <code>function</code>\nThe name of the <code>Int</code> type: <code>int&lt;N&gt;</code>\nInt - <code>intX</code>\nThe signed integer Rust representation.\nSpecifies the number of bits in an <code>Int</code> or <code>Uint</code> as a type.\nThe name of the <code>FixedBytes</code> type: <code>bytes&lt;N&gt;</code>\nThe difference between the representation’s and this …\nString - <code>string</code>\nStatically guarantees that a <code>FixedBytes</code> byte count is …\nStatically guarantees that a <code>Int</code> or <code>Uint</code> bit count is …\nThe name of the <code>Uint</code> type: <code>uint&lt;N&gt;</code>\nUint - <code>uintX</code>\nThe unsigned integer Rust representation.\nThe index of the most significant byte in the Word type.\nThe index of the most significant byte in the Word type.\nDetokenizes a signed integer.\nDetokenizes an unsigned integer.\nABI-encode a signed integer in packed mode.\nABI-encode an unsigned integer in packed mode.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nTokenizes a signed integer.\nTokenizes an unsigned integer.\nSee <code>usize::next_multiple_of</code>.\nCalculates the padded length of a slice by rounding its …\nCalculates the padded length of a slice of a specific …")
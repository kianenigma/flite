searchState.loadedDescShard("ethabi_decode", 0, "ABI Address\nAddress.\nAddress.\nArray of unknown size.\nArray of params with unknown size.\nBoolean.\nBoolean value.\nBytes.\nVector of bytes of unknown size.\nContract event.\nArray with fixed size.\nArray with known size.\nVector of bytes with fixed size.\nVector of bytes with known size.\nHash Fixed-size uninterpreted hash type with 32 bytes (256 …\nSigned integer.\nSigned integer.\nInvalid data.\nInvalid entity such as a bad function name.\nMaximum value.\nEvent param specification.\nFunction and event param types.\nString.\nString.\nEthereum ABI params.\nTuple containing different types\nTuple of params of variable types.\nABI Int and UInt Little-endian large integer type 256-bit …\nUnsigned integer.\nUnisnged integer.\nABI word.\nComputes the absolute difference between self and other.\nIf anonymous, event cannot be found using <code>from</code> filter.\nExtracts a byte slice containing the entire fixed hash.\nExtracts a mutable byte slice containing the entire fixed …\nExtracts a reference to the byte array containing the …\nExtracts a reference to the byte array containing the …\nReturns a mutable raw pointer to the value.\nReturns a constant raw pointer to the value.\nConversion to u128 with overflow checking\nConversion to u32 with overflow checking\nConversion to u64 with overflow checking\nConversion to usize with overflow checking\nAssign the bytes from the byte slice <code>src</code> to <code>self</code>.\nReturn if specific bit is set.\nReturn the least number of bits needed to represent the …\nReturn specific byte.\nChecked addition. Returns <code>None</code> if overflow occurred.\nChecked division. Returns <code>None</code> if <code>other == 0</code>.\nChecked multiplication. Returns <code>None</code> if overflow occurred.\nChecked negation. Returns <code>None</code> unless <code>self == 0</code>.\nChecked exponentiation. Returns <code>None</code> if overflow occurred.\nChecked modulus. Returns <code>None</code> if <code>other == 0</code>.\nChecked subtraction. Returns <code>None</code> if overflow occurred.\nReturns <code>true</code> if all bits set in <code>b</code> are also set in <code>self</code>.\nDecodes ABI compliant vector of bytes into vector of …\nReturns a pair <code>(self / other, self % other)</code>.\nEncodes vector of tokens into ABI compliant vector of …\nCreate <code>10**n</code> as this type.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nConstructs a hash type from the given reference to the …\nReturns the argument unchanged.\nConstructs a hash type from the given bytes array of fixed …\nConstructs a hash type from the given reference to the …\nConverts from big endian representation bytes in memory.\nConvert from a decimal string.\nConverts from little endian representation bytes in memory.\nCreates a new hash type from the given <code>u64</code> value.\nCreates a new hash type from the given <code>u64</code> value.\nCreates a new hash type from the given <code>u64</code> value.\nCreate a new fixed-hash from the given slice <code>src</code>.\nCreates a hash type instance from the given string.\nConverts a string slice in a given base to an integer. …\nMultiplies two 256-bit integers to produce full 512-bit …\nIndexed flag. If true, param is used to build block bloom.\nEvent input.\nCompute the highest <code>n</code> such that <code>n * n &lt;= self</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nreturns whether a ParamKind is dynamic used to decide how …\nCheck if the token is a dynamic type resulting in prefixed …\nreturns whether a zero length byte slice (<code>0x</code>) is a valid …\nWhether this is zero.\nReturns <code>true</code> if no bits are set.\nParam type.\nReturns the number of leading zeros in the binary …\nReturns the size of this hash in bytes.\nLow 2 words (u128)\nConversion to u32\nLow word (u64)\nThe maximum value which can be inhabited by this type.\nOne (multiplicative identity) of this type.\nAddition which overflows and returns a flag if it does.\nMultiply with overflow, returning a flag if it does.\nNegation with overflow.\nFast exponentiation by squaring. Returns result and …\nSubtraction which underflows and returns a flag if it does.\nFast exponentiation by squaring …\nCreate a new hash with cryptographically random content.\nCreate a new hash with cryptographically random content …\nAssign <code>self</code> to a cryptographically random value.\nAssign <code>self</code> to a cryptographically random value using the …\nReturns a new fixed hash where all bits are set to the …\nAddition which saturates at the maximum value (Self::MAX).\nMultiplication which saturates at the maximum value..\nSubtraction which saturates at zero.\nEvent signature. Like “Foo(int32,bytes)”.\nConverts token to…\nConverts token to…\nWrite to the slice in big-endian format.\nConverts token to…\nConverts token to…\nConverts token to…\nConverts token to…\nReturns the inner bytes array.\nConverts token to…\nWrite to the slice in little-endian format.\nReturns the lowest 8 bytes interpreted as big-endian.\nReturns the lowest 8 bytes interpreted as little-endian.\nReturns the lowest 8 bytes interpreted as native-endian.\nConverts token to…\nConverts token to…\nReturns the number of trailing zeros in the binary …\nCheck whether the type of the token matches the given …\nCheck if all the types of the tokens match the given …\nZero (additive identity) of this type.\nReturns a new zero-initialized fixed hash.")
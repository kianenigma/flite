searchState.loadedDescShard("snowbridge_amcl", 0, "Returns the argument unchanged.\nCalls <code>U::from(self)</code>.\nReset cipher.\nAdd\nBit\nConditional Move\nCompare\nConditional Swap\nDouble\nDouble Copy\nDecrement\nDivision\nDivide 3\nReturns the argument unchanged.\nFrom Byte Array\nFrom bytes\nFrom String\nPartial Shift Left\nPartial Shift Right\nGet\nInteger Multiplication\nIncrement\nCalls <code>U::from(self)</code>.\nInverse Modulus 256\nInverse Modulu 2^m\nInverse Modulus\nIs Unity\nIs Zilch\nJacobi Symbol\nLast Bits\nMinus\nMod 2^m\nModular Multiplication\nModular Negation\nreturn a^2 mod m\nMontegomery Reduction\nMultiplication\nMultiply Addition\nNumber of Bits\nNew\nNew Double Copy\nNew Int\nNew Ints\nNormalise\nOne\nOR\nParity\nPlus\nP Multiply\nRaise to Power with Modulus\nPX Multiply\nRandom\nRandom Number\nReduciton with Modulus\nReverse Subtraction\nSet\nShift Left\nShift Right\nSmall Multiply\nSquare\nSSN\nSubtraction\nTo Byte Array\nTo Bytes\nTo String\nXOR Top\nZero\nBLS12-381\nDomain Separation Tag for signatures on G1\nDomain Separation Tag for signatures on G2\nThe required number of bytes for a compressed G1 point\nThe required number of bytes for a compressed G2 point\nThe required number of bytes for a secret key\nAggregate\nAggregate\nBasic Scheme - AggregateVerify\nBasic Scheme - AggregateVerify\nMessage Augmentation - KeyGenerate\nGenerate key pair - (secret key, public key)\nGenerate key pair - (secret key, public key)\nSecret Key To Public Key\nSecret Key To Public Key\nBasic Scheme - Sign\nBasic Scheme - Sign\nBasic Scheme - Verify\nBasic Scheme - Verify\nDomain Separation Tag for signatures on G1\nDomain Separation Tag for signatures on G2\nThe required number of bytes for a compressed G1 point\nThe required number of bytes for a compressed G2 point\nThe required number of bytes for a secret key\nAggregate\nAggregate\nMessage Augmentation - AggregateVerify\nMessage Augmentation - AggregateVerify\nMessage Augmentation - KeyGenerate\nGenerate key pair - (secret key, public key)\nGenerate key pair - (secret key, public key)\nSecret Key To Public Key\nSecret Key To Public Key\nMessage Augmentation - Sign\nMessage Augmentation - Sign\nMessage Augmentation - Verify\nMessage Augmentation - Verify\nDomain Separation Tag for signatures on G1\nDomain Separation Tag for signatures on G2\nDomain Separation Tag for PopProve and PopVerify for …\nDomain Separation Tag for PopProve and PopVerify with …\nThe required number of bytes for a compressed G1 point\nThe required number of bytes for a compressed G2 point\nThe required number of bytes for a secret key\nAggregate\nAggregate\nProof of Possession - AggregateVerify\nProof of Possession - AggregateVerify\nProof of Possession - FastAggregateVerify\nProof of Possession - FastAggregateVerify\nProof of Possession - KeyGenerate\nGenerate key pair - (secret key, public key)\nGenerate key pair - (secret key, public key)\nProof of Possession - PopProve\nProof of Possession - PopProve\nProof of Possession - PopVerify\nProof of Possession - PopVerify\nSecret Key To Public Key\nSecret Key To Public Key\nProof of Possession - Sign\nProof of Possession - Sign\nProof of Possession - Verify\nProof of Possession - Verify\nTake a 48 or 96 byte array and convert to a G1 point (x, y)\nTake a 96 or 192 byte array and convert to G2 point (x, y)\nHash to Curve\nHash to Curve\nTake a G1 point (x, y) and compress it to a 48 byte array.\nTake a G2 point (x, y) and compress it to a 96 byte array …\nTake a G1 point (x, y) and converti it to a 96 byte array.\nTake a G2 point (x, y) and convert it to a 192 byte array …\nself += x\nCompare a and b, return 0 if a==b, -1 if a&lt;b, +1 if a&gt;b. …\nreturn self / c\nReduces self DBig mod a Big, and returns the Big\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nset x = x mod 2^m\nReturn number of bits\nCreates new DBig as 0.\nNew Small Copy\nNormalise Big - force all digits &lt; 2^big::BASEBITS\nself = x - self\nGeneral shift left\nGeneral shift right\nSplit DBig\nself -= x\nConvert to Hex String\nCopy from a Big\nAddition\nAffine\nConditional Move\nConditional Swap\nDifferential Add for Montgomery curves.\nDouble\nEquals\nReturns the argument unchanged.\nFrom Bytes\nFrom Hex\nFrom Hex Iterator\nGenerator\nGet Proejctive X\nGet Projective Y\nGet Porjective Z\nGet Sign Y\nGet X\nGet Y\nInfinity\nCalls <code>U::from(self)</code>.\nIs Infinity\nMap It\nMultiplication\nMultiply two points by scalars\nMultiply X\nNegation\nNew\nNew Big\nNew BigInt\nNew Bigs\nNew Fp’s\nNew Projective\nPin Multiplication\nProjective New\nSubtraction\nTo Bytes\nTo Hex\nTo String\nElliptic Curve Point over Fp2\nReturns the argument unchanged.\nFrom Bytes\nFrom Hex\nFrom Hex Iterator\nGenerator\nCalls <code>U::from(self)</code>.\nMap It\nMultiplication\nMultiply 4 Points\nNew\nNew Fp2\nNew Fp2’s\nNew Porjective\nTo Hex\nTo String\nself+=b\ncopy from Big b\ncopy FPs depending on d\nswap FPs depending on d\nself+=self\nself/=2 mod Modulus\nreturn TRUE if self==a\nModular Inverse for pseudo-Mersenne primes\nReturns the argument unchanged.\nFrom Hex\nFrom Hex Iterator\nthis*=c mod Modulus, where c is a small int\nCalls <code>U::from(self)</code>.\nself=1/self mod Modulus\nCheck if self is 0\nreturn jacobi symbol (this/Modulus)\nModulo\nthis*=b mod Modulus\nthis = -this mod Modulus\nNew\nNew Big\nNew Int\nNew Ints\nnormalise this\nset this=1\nPower\nReduce\nreduce this mod Modulus\nself=b-self\nChecks sign of a field element\nself*=self mod Modulus\nSquare Root\nself-=b\nTo Hex\nTo String\nset this=0\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nTo String\nReturns the argument unchanged.\nFrom Hex\nFrom Hex Iterator\nCalls <code>U::from(self)</code>.\nNew\nNew Big\nNew Bigs\nNew Fp\nNew Fp’s\nNew Int\nNew Ints\nChecks sign of a field element\nTo Hex\nTo String\nEquals\nReturns the argument unchanged.\nFrom Hex\nFrom Hex Iterator\nGet A\nGet B\nCalls <code>U::from(self)</code>.\nInverse\nNew Fp4\nNew Fp2\nNew Fp2’s\nNew Int\nPower\nReal\nTo String\nXTR Power\nXTR Power 2\nOversized DST padding\nReturns the argument unchanged.\nHash a message\nCalls <code>U::from(self)</code>.\nImplement step 1 on client side of MPin protocol\nImplement step 2 on client side of MPin protocol\nCalculate common key on client side wCID = w.(A+AT)\nExtract factor from TOKEN for identity CID\nExtract PIN from TOKEN for identity CID\nTime Permit CTT=S*(date|H(CID)) where S is master secret\nClient secret CST=S*H(CID) where CID is client ID and S is …\nW=x<em>H(G); if RNG == NULL then X is passed in if RNG != NULL </em>…\nExtract Server Secret SST=S*Q where Q is fixed generator …\nGenerate Y = H(epoch, xCID/xID)\nHash the M-Pin transcript - new\nPollards kangaroos used to return PIN error\nFunctions to support M-Pin Full\ncreate random secret S\nR=R1+R2 in group G1\nW=W1+W2 in group G2\nRestore factor to TOKEN for identity CID\nOutputs H(CID) and H(T|H(CID)) for time permits. If no …\nImplement step 2 of MPin protocol on server side\ncalculate common key on server side Z=r.A - no time …\nL = ceil(ceil(log2(p) + 128) / 8)\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nThe block size of each round.\nHash Length in Bytes\nReturns the argument unchanged.\nGenerate 32-byte Hash\nHKDF-Extend\nHKDF-Extract\nGenerate a HMAC\nInitialise Hash function\nCalls <code>U::from(self)</code>.\nProcess a single byte\nProcess an array of bytes\nProcess a 32-bit integer\nThe block size of each round.\nHash Length in Bytes\nReturns the argument unchanged.\nGenerate 48-byte Hash\nHKDF-Extend\nHKDF-Extract\nGenerate a HMAC\nInitialise Hash function\nCalls <code>U::from(self)</code>.\nProcess a single byte\nProcess an array of bytes\nProcess a 32-bit integer\nThe block size of each round.\nHash Length in Bytes\nReturns the argument unchanged.\nHKDF-Extend\nHKDF-Extract\nGenerate a HMAC\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.")